/*
*
*
* each file in the git repo is, in this project, considered a "section" (of the legislation)
* the local working directory is the nodegit-tmp folder
* all operations are done in this folder
* the app clones the remote repo (once) at {app}/clone and saves it into the nodegit-tmp folder
* it pulls in ('fetch' and 'merge' git commands) the latest version of the remote repo at {app}/update
* {app}/open and {app}/read  were just for basic building blocks, do not currently provide essential functionality
* {app}/open gets the commit message of the most recent commit
* {app}/read reads each file in the file system 'fs' (which is now under the {app}/ main page)
* Each div on main page is now the text of each file in the git repo
* Next step: Auto-update on main page load and/or button click (currently you must go to '{app}/update' to pull in latest repo)
* Next step: Allow any edited changes in editable divs to be saved locally and pushed to remote repo
*
*
* {app}/nodegit pushes any changes to files "NewFile.txt" and "NewFile2.txt" to a remote Github repo
* Writing new content (as generated by the user) to the files is code that is so far unwritten
* As is code which determines which file was altered, and thus which file to include in a new commit
* Currently I'm manually changing "NewFile.txt" and "NewFile2.txt"
* but the connection to Github and the ability to push files are working
* Next step: See if you can get a file's revision history, then if you can compare current version to previous version?
*
*
*/

// init project
const express = require('express');
const app = express();

const nodegit = require("nodegit");
const path = require("path"); // native to Node

const url = "https://github.com/lieberscott/git-nodegit.git";
const user = process.env.USER;
const pass = process.env.PASS;
const localDir = "./git-nodegit";

const fs = require("fs");
const newLocalDir = './nodegit-tmp';

const callbacksObj = {
  callbacks: {
    certificateCheck: () => 1,
    credentials: (url, userName) => nodegit.Cred.userpassPlaintextNew(user, pass)
  }
};

const signature = nodegit.Signature.now("Author", "Commiter");

let repo, index, oid, remote;

let sectionsArr = [];

// const SSH = process.env.SSH;

// http://expressjs.com/en/starter/static-files.html
app.use(express.static("public"));
app.set('view engine', 'pug');

// http://expressjs.com/en/starter/basic-routing.html
// app.get('/', (req, res) => {
//   res.render(process.cwd() + "/views/index.pug");
// });

app.get('/', (req, res) => {
  
  fs.readdir(newLocalDir, (err, files) => {
    console.log("zeroth checkpoint");
    files.forEach((file, index) => {
      if (file == ".git") {
        // do nothing
      }
      else {
        console.log("first checkpoint : ", file);
        let x = fs.readFileSync("./nodegit-tmp/" + file, 'utf8');
        console.log(x);
        sectionsArr[index] = x;
      }
    });
  });
  
  sectionsArr.forEach(item => {
    console.log(item)
  });
  
  res.render(process.cwd() + "/views/index.pug", { sectionsArr });
});

app.get('/nodegit', (req, res) => {
  
  nodegit.Repository.open(localDir)
    .then((repository) => {
      repo = repository;
      return;
    })
    .then(() => repo.refreshIndex()) // Refresh the directory (not totally sure what that means!!)
    .then((oid) => {
      // ([array of files to commit], author, commiter, message)
      return repo.createCommitOnHead(["newFile.txt", "newFile2.txt"], signature, signature, "new commit with two files");
    })
    .then((oidNum) => {
      oid = oidNum; // unused, but may need it for other operations later on
      return repo.getRemote("origin");
    })
    .then((remoteResult) => {
      remote = remoteResult;
      return remote.connect(nodegit.Enums.DIRECTION.PUSH, {
        credentials: (url, userName) => nodegit.Cred.userpassPlaintextNew(user, pass)
      });
    })
    .then(() => remote.push(["+refs/heads/master:refs/heads/master"], callbacksObj))
    .catch((err) => console.log(err)); // that's all!
  
  res.json({ response: "nodegit" });
});

app.get('/clone', (req, res) => {
  
  nodegit.Clone("https://github.com/lieberscott/git-nodegit", "nodegit-tmp").then((repository) => {
    // Work with the repository object here.
    console.log(repository);
  })
  .catch((err) => console.log(err)); // that's all!
  
  res.json({ response: "clone" });
});

app.get('/open', (req, res) => {
  
  const getMostRecentCommit = (repository) => {
    return repository.getBranchCommit("master");
  };

  const getCommitMessage = (commit) => {
    return commit.message();
  };

  nodegit.Repository.open("nodegit-tmp")
    .then(getMostRecentCommit)
    .then(getCommitMessage)
    .then((msg) => {
      console.log(msg);
  });
  
  res.json({ response: "open" });
  
});

app.get('/update', (req, res) => {
  // Open a repository that needs to be fetched and fast-forwarded
  nodegit.Repository.open(path.resolve(__dirname, newLocalDir))
    .then((repository) => {
      repo = repository;

      return repository.fetchAll({
        callbacks: {
          credentials: function(url, userName) {
            return nodegit.Cred.sshKeyFromAgent(userName);
          },
          certificateCheck: function() {
            return 1;
          }
        }
      });
    })
    // Now that we're finished fetching, go ahead and merge our local branch
    // with the new one
    .then(function() {
      return repo.mergeBranches("master", "origin/master");
    })
    .done(function() {
      console.log("Done!");
    });
  
  res.json({ response: "update" });
});

app.get('/read', (req, res) => {
  fs.readdir(newLocalDir, (err, files) => {
    files.forEach(file => {
      console.log(file);
    });
  });
  
  let readMe = fs.readFileSync('./nodegit-tmp/README.md', 'utf8');
  console.log(readMe);
  
  res.json({ response: "read" });
  
});

// listen for requests :)
let listener = app.listen(process.env.PORT, function() {
  console.log("Your app is listening on port " + listener.address().port);
});
